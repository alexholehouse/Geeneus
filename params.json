{"name":"Geeneus","tagline":"Hyper simple protein and gene API for Entrez NCBI databases","body":"# geeneus\r\n`Current version: 0.1.9`\r\n### Remote protein record access made simple\r\n\r\n**NOTE: This github page hosts the development version, but not the distribution version. To get and install the current stable version of `geeneus` use `pip`**\r\n\r\n       [sudo] pip install geeneus\r\n\r\n**The command above will install the current stable release. **\r\n\r\nTo upgrade to the current stable release, we recommend the command\r\n\r\n    pip install -U --no-deps geeneus\r\n    \r\nThe `--no-deps` flag means geenues is the *only* package which is updated \r\n(i.e. no dependencies)\r\n\r\n### Introduction\r\n**geeneus** is designed as a simple to use, robust and reliable Python API to obtain biological record information (currently only protein data is supported). The tool primarily uses NCBI's protein database, but falls back on the EBI UniProt database in a totally seamless fashion if needed.\r\n\r\nThe motivation comes from the simple fact that when I began working with NCBI's databases I wanted an interface that allowed me to run a command like:\r\n\r\n       interface.get_protein_sequence(accession_number)\r\n\r\nand the command would just return the sequence associated with that accession number. This didn't exist, so I decided to create it.\r\n\r\nThe primary focus of **geeneus** from day one has been ease of use. NCBI allows access to their records through an Entrez based RESTful API called [eUtils](http://www.ncbi.nlm.nih.gov/books/NBK25500/). However, this can be complicated to set up, and to people who are less familiar with networking or programming this can pose a major barrier to access. [Biopython](http://biopython.org/) goes some way [to help with this](http://biopython.org/DIST/docs/tutorial/Tutorial.html#htoc98), but still requires the user to parse XML, deal with networking, read handles, and lots of other things which are just more work.\r\n\r\nConsidering this, my goals were to;\r\n\r\n* Parse the returned XML - the user should *never* have to deal with XML unless they want to (note the raw XML associated with a record is still easily available!)\r\n\r\n* Deal with all the networking errors - the user should be able to turn their internet connection off while running and the system won't crash (it will probably stop getting results though)\r\n\r\n* Abstract any of the complexity to create a uniform and easy to use, API which returns built-in types. This means the various functions only return strings, lists, tuples and dictionaries.\r\n\r\n### Installation\r\nThe simplest way to is to just use `pip` (note there's no need to download anything here, `pip` downloads the source from the package index database and then installs it)\r\n\r\n       [sudo] pip install geeneus\r\n\r\nMore installation options can be found [here](http://pypi.python.org/pypi/Geeneus/). \r\n\r\nPlease note that I (and probably everyone else who uses Python) would **strongly recommend using a virtualenv** for installing packages, rather than the default system-wide Python. If you're unfamiliar with `virtualenv`, take a look [at this guide](http://docs.python-guide.org/en/latest/dev/virtualenvs/). \r\n\r\n### Usage\r\n\r\nFor now only protein record access usage is provided, as the gene record functionality is still in development. However, the backend provides an extendable framework for abstracting networking, caching records and error handling, such that the addition of additional data types is reasonably straight forward (i.e. the only additional code needed is record type specific XML parsing)\r\n\r\n**geeneus** as a package contains a module for each type of record you might want to parse (protein, gene etc). To set up for protein records, you do;\r\n\r\n       from geeneus import Proteome\r\n       manager = Proteome.ProteinManager(\"your.emailaddress@email.com\")\r\n\r\nAnd from there, the NCBI/UniProt protein data is at your fingertips. Say we want the sequence for the *protein sprouty homolog 4 isoform 2*. This protein has the accession number \"`NP_001120968`\", so we simply do\r\n\r\n       manager.get_protein_sequence(\"NP_001120968\")\r\n\r\nand we're greeted with the sequence (formatting for easy reading here)\r\n\r\n       'meppipqsap ltpnsvmvqp lldsrmshsr lqhpltilpi dqvktshve ndyidnpsla \r\n        lttgpkrtrg gapelaptpa rcdqdvthhw isfsgrpssv ssssstssd qrlldhmapp          \r\n        pvadqaspra vriqpkvvhc qpldlkgpav ppeldkhfll ceacgkckc kecasprtlp \r\n        scwvcnqecl csaqtlvnyg tcmclvqgif yhctneddeg scadhpcsc srsnccarws\r\n        fmgalsvvlp cllcylpatg cvklaqrgyd rlrrpgcrck htnsvicka asgdaktsrp \r\n        dkpf'\r\n\r\nFor the full range of functions available see below, or try `help(manager)` or `help(geneeus.Proteome)`. \r\n\r\nNote that geeneues does not offer any searching capabilities.\r\n\r\n## Functions\r\nBelow there is a brief reference list for the available functions. The '*datastore*' being mentioned here refers to the internal storage structure that holds the data as it's parsed and stored.\r\n\r\n### List of access modules\r\n    Proteome # for accessing protein data\r\n    Genome   # for accessing gene information (currently non-functional)\r\n\r\n### List of Proteome functions\r\n\r\n#### Protein Manager initializer parameters (default in parentheses)\r\n    email                 # required for NCBI database access\r\n\r\n    cache (True)          # True or False: If set to True then the\r\n                            datastore cache's records, while if False\r\n                            a new record is downloaded on every                             \r\n                            request. Unless you have a very specific\r\n                            reason it is highly recommended to\r\n                            keep this as True\r\n\r\n    retry (0)             # Number of retries the NCBI networking\r\n                            protocols use if access fails\r\n\r\n    uniprotShortut (True) # If true we check UniProt first and\r\n                            exclusivly for some record types (see\r\n                            the section \"Shortcutting\" below)\r\n\r\n#### Introspective functions (queries relating to the datastore)\r\n    has_key(ID)              # Check if an ID is currently cached in \r\n                               the datastore (does not trigger downloading\r\n                               on False)\r\n\r\n    keys()                   # Returns a list of all the protein IDs in the              \r\n                               datastore\r\n\r\n    datastore_size()         # Get the number of records in the datastore\r\n\r\n    purge()                  # Delete all data from the datastore\r\n\r\n    error(ID)                # See if the record associated with this ID\r\n                               caused an error (discussed below in more\r\n                               detail)\r\n\r\n    exists(ID)               # See if the protein record associated with \r\n                               this ID exists (discussed below in more  \r\n                               detail)\r\n\r\n    run_translation(ID)      # Function to translate an accession to a GI \r\n                              (uses a call to the NCBI lookup server)\r\n\r\n    save_datastore(filenam)  # Saves the underlying datastore to be reloaded\r\n                               by geeneus at some future date.\r\n\r\n    load_datastore(filename) # Loads a previously saved datastore. NOTE this does\r\n                               not do any sanity checking so DO NOT try and load\r\n                               something not created by geeneus\r\n\r\n#### Protein record functions (queries relating to the record)\r\n    get_record_source(ID)        # determine which database this \r\n                                   record was downloaded from (will \r\n                                   return either 'NCBI' or 'UniProt')\r\n                            \r\n    get_record_creation_date(ID) # get the date the record was created\r\n                                   in the database (not the datastore) \r\n\r\n    get_record_version(ID)       # get the record version (discussed     \r\n                                   in more detail below)\r\n\r\n    get_ID_type(ID)              # returns a 2 position list where  \r\n                                   [0] is an exit code and [1] is \r\n                                   the name of the ID type (if it \r\n                                   meets the criterion for any \r\n                                   specific type\r\n\r\n#### Protein information functions (queries relating to the protein)\r\n    get_raw_xml(ID)                 # get an XML string for the record\r\n\r\n    get_protein_name(ID)            # get the protein name\r\n\r\n    get_protein_sequence(ID)        # get the amino acid sequence\r\n\r\n    get_protein_sequence_length(ID) # get number of amino acids in \r\n                                      sequence\r\n\r\n    get_geneID(ID)                  # if the protein is associated \r\n                                      with a specific gene ID then \r\n                                      this returns that ID\r\n\r\n    get_gene_name(ID)               # if the protein is associated \r\n                                      with a specific gene then \r\n                                      this returns that gene's name\r\n\r\n    get_variants(ID)                # get a list of variant \r\n                                      dictionaries (covered in detail \r\n                                      in a later section)\r\n\r\n    get_isoforms(ID)                # get a list of isoforms indexed\r\n                                      by their isoform reference \r\n                                      (covered in detail in a later\r\n                                      section)\r\n\r\n    get_domains(ID)                 # get a list of the PFAM \r\n                                      identified domains (covered in\r\n                                      detail later)\r\n\r\n    get_other_accessions(ID)        # get a list of other accessions\r\n                                      which also point at this record\r\n\r\n    get_taxonomy(ID)                # get the ordered taxonomy list of\r\n                                      the species this protein  \r\n                                      originates from\r\n\r\n    get_species(ID)                 # get the species of origin\r\n\r\n    get_host(ID)                    # get the host of the species if this \r\n                                      is a viral protein, else returns an\r\n                                      'N/A' string\r\n\r\n#### Batch protein information functions\r\n    batch_get_protein_sequence(List) # returns a list which  \r\n                                       corresponds with the input list\r\n                                       of protein sequences\r\n\r\n    batch_get_protein_name(List)     # returns a list which  \r\n                                       corresponds with the input list\r\n                                       of protein names\r\n\r\n    batch_get_variants(List)         # returns a list which  \r\n                                       corresponds with the input list\r\n                                       of protein variants lists\r\n\r\n\r\n#### Genome functions\r\n    Currently untested, so best to ignore for the time being...\r\n    \r\n## Complex return types\r\nDomains, variants, isoforms and other_accessions queries return complex structures (i.e. not a string or an integer). To understand what is being returned we briefly summarize them here. We also have a quick discussion on version numbers, UniProt shortcutting, and on `error` and `exists` statuses.\r\n\r\n#### Domains\r\nA domain query returns a list of domain dictionaries, where each dictionary has the following key value pairs;\r\n\r\n    start        # domain start location\r\n    stop         # domain stop location\r\n    type         # domain type (currently always `pfam`, but left in for \r\n                   potential upgrades to different domain recognition \r\n                   approaches in the future)\r\n    label        # label information\r\n    accession    # accession associated with the domain\r\n\r\n#### Variants\r\n*UPDATE IN 0.1.6: Previously the key names were capitalized (e.g. 'Location', 'Original' etc). To add consistency with other complex types keys are now all lower case*\r\n\r\nA variant query returns a list of variant dictionaries, where each dictionary has the following key value pairs;\r\n\r\n    location   # start location of the variant being reported\r\n    original   # original amino acid(s) at location\r\n    mutant     # new amino acid(s) at location\r\n    variant    # a convenient X -> Y string for easy visualization of\r\n                 what the variant is\r\n    type       # Describes the type of variant \r\n    notes      # any annotation provided in the reference database as\r\n                 well as mutation references where possible\r\n\r\nFor `type` there are a number of possible values;\r\n\r\n    \"Deletion\"                 # represent regions or amino acids\r\n                                 which are missing (e.g. AGDDT -> -)\r\n    \"Deletion & substitution\"  # represents the situation where the\r\n                                 mutant is shorter and but other amino\r\n                                 acids are added (e.g. AGH -> AK)\r\n    \"Insertion\"                # represent situations where the\r\n                                 mutated version is longer than the\r\n                                 original but the original is still  \r\n                                 present (e.g A -> AKL)\r\n    \"Insertion & substitution\" # represent situations where the\r\n                                 mutated version is longer than the \r\n                                 original and we lose the original \r\n                                 (e.g. A -> GKL)\r\n    \"Substitution (single)\"    # Single amino acid switch (e.g. A->G)\r\n    \"Substitution (double)\"    # Double amino acid switch \r\n                                 (e.g. AK -> GL)\r\n    \"Substitution (<X>)\"       # Greater than 2 substitution where <X>\r\n                                 is the length of the exchange \r\n                                 (e.g. if <X> = 4 then AKHI -> CDYW)\r\n\r\n\r\n\r\nOne potentially confusing is the use of DNA-typical vocabulary (insertion, deletion and subsitution) when talking about variant changes. It was decided that these provide appropriate and easy to understand terms, even if they typically refer to changes in DNA, not amino acid sequence. It's important to remember that a single substitution of an amino acid does not necessarily correspond to a SNP, and these descriptions refer *exclusively* to changes to the amino acid sequence, not the underlying DNA sequence.\r\n\r\n#### Isoforms\r\nIsoform queries return dictionary, where each key value is keyed by the isoform ID (which has the form \"accession-X\" e.g. Q12345-3). The value is a 2 position list, where position 0 is the isoform name/reference number and position 1 is the full isoform sequence. \r\n\r\nFor example, a protein with one isoform (Q12345-2) might return the following dictionary\r\n\r\n       {'Q1234-2':['2','GTAGHKLPKKLRSDF']}\r\n\r\nIsoforms present some difficulties. Isoforms are defined in NCBI records in two different ways.\r\n\r\nOne set are based on feature annotation. A canonical record will have a number of features which describe the change in the various isoforms relative to that canonical sequence. Those isoforms don't have their own records - they exist as annotations in a canonical record and their sequences are represented as Q12345-X. **geeneus** can reconstruct these isoform amino acid sequences based on the annotations, which is how it builds the NCBI isoform lists (UniProt isoforms are each individually defined and linked to the reference record, so no reconstruction is required). One additional complication is that each isoform has both an isoform ID (Q12345-X) and an isoform name (isoform Y). While often X and Y are the same this is not always the case, sometimes Y is a word name (such a small, short, beta etc). More unhelpfully, sometimes Y is a number, but a *different* number to the isoform ID X value. \r\n\r\nThe other set exist as stand alone records, often with \"isoform\" in their name. These records unhelpfully includes no references to other isoforms, or to the canonical sequence/record from which they relate to. Similarly, canonical sequences have no reference to their \"isoform\" records. As such there is no way to include these in the list of isoforms (although they do have their own accession values as a result of existing as their own records). It is therefore up to the user to identify such isoforms. Theoretically, you could query the entire list of cross-referenced accessions and compare names to try and identify isoforms, but this would be a hugely expensive (in terms of network traffic) and there's no guarantee any/all isoforms would be included in the cross reference section.\r\n\r\n**NB:** If you want to request a specific isoform sequence using the dash notation, doing \r\n\r\n       manager.get_protein_sequence(\"Q12345-5\") \r\n\r\nwill return **the canonical sequence**, not the isoform sequence.\r\n\r\nInstead, you need to do\r\n\r\n       manager.get_isoforms(\"Q12345-5\")[\"Q12345-5\"][1]\r\n       # or\r\n       manager.get_isoforms(\"Q12345\")[\"Q12345-5\"][1]\r\n\r\nThis will do the following\r\n\r\n* Get the record associated with `Q12345`, then get the isoforms\r\n* Pull out the isoform data associated with `Q12345-5`\r\n* As discussed above, the isoform data is a tuple of (`name`, `sequence`) so position 1 gives you the sequences\r\n\r\nIt would probably be wise to wrap this in a `try/except` block in case the isoform ID is missing, such as\r\n\r\n       try:\r\n          manager.get_isoforms(\"Q12345-5\")[\"Q12345-5\"][1]\r\n       except KeyError:\r\n          print \"Isoform ID not found\"\r\n\r\n\r\n\r\n#### Other accession\r\nOther accession queries returns a list of tuples which define, (`type of accession`, `accession`).  The type of accession will be one of the following;\r\n\r\n* \"UniProtKB/Swiss-Prot\"\r\n* \"RefSeq\"\r\n* \"GI\"\r\n* \"PDB\"\r\n* \"International Protein Index\"\r\n* \"DDBJ\"\r\n* \"GenBank\"\r\n* \"EMBL\"\r\n* \"Unknown accession type\"\r\n\r\nThe way **geeneus** classifies these accession types is based on a set of hardcoded regular expressions. If you expect one accession type to be classified as something it's not, this may be an error in either how these values are parsed or the defining regular expressions, so please submit a bug report!\r\n\r\n## Record versions\r\nAccession versioning is done by appending a period followed by a version number, e.g. Q12345.1 or Q12345.2 would be two different versions of the same record. Versioning represents updates made to records, typically as new information becomes available.\r\n\r\nOne potential source of problems is that NCBI records obtained directly through the eUtils interface (as opposed to through the website) do not contain any information on related versions. This means that **geeneus** is unable to give this information either.\r\n\r\nQuerying a non-versioned accession (e.g. Q12345 or NP_1234567) will give the most up-to-date record associated with that accession, while querying a versioned value (Q12345.3 or NP_1234567.5) will give that specific version. However, there is no way to know if any specific versioned record is the most up-to-date record, or access previous records. This is not *necessarily* a problem, it's just worth being aware that if you query with explicit version numbers this may not give the most up to date version. \r\n\r\nNote that GI numbers are unique for each different version, so deal with versioning in a different manner. The `version` number returned here refers to the non-GI accession version, where available. If no explicit version is available then we assume the version is 1.\r\n\r\n## Shortcutting\r\nShortcutting allows **geeneus** to bypass the NCBI servers entirely for UniProtKB/Swiss-Prot accession values which NCBI doesn't guarantee to support (e.g. all of them except those beginning with O, P or Q) and go directly to the UniProt servers, both in batch mode and individual mode.\r\n\r\nThis leads to a *massive* increase in performance when dealing with large number of accessions which meet this criterion as we avoid countless database misses, retry-rounds, and the eventual fallback to UniProt and just go straight there from the word go. \r\n\r\n## Error and Exists status\r\n`error` and `exists` represent two flags to help deal with problems.\tIf a networking request fails, this sets a records `error` flag to true, and any of the other methods return `None`. In this case, `exist` is also set to False, as the record does not exist in the datastore. \r\n\r\nSometimes we may obtain a record correctly and without error, but find that it does not represent a valid protein record. If this happens we have not triggered an error (so error=False), but the record does not exists, in which case `exist` is also set to False. In these instances all methods *except* the `get_raw_xml()' method return `None`, but `get_raw_xml()` will return the xml for further inspection.\r\n\r\n*UPDATE IN 0.1.6: Previously if an error=True or exists=False the methods would return empty strings, lists of dictionaries. This can be dangerously ambiguous, so the behavior was changed to return None (equivalent to NA, or unknown)*\r\n\r\n## Design Decisions\r\n\r\n### UniProt fallback\r\n**NB** *The discussion below is more relevant when* `uniprotShortcut` *is set to* `False`.\r\n\r\nNCBI guarantees support for UniProt/Swissprot IDs which begin with O, P or Q. However, it also offers some support for other types of UniProt IDs (i.e. those which begin with other letters). There is sometimes a discrepancy between those which are available through the website and through the eUtils interface, where the eUtils lookup fails on an accession that should succeed. To deal with this, **geeneus** can use UniProt IDs and fall back on the UniProt servers. Dealing with UniProt calls instead of NCBI calls is more expensive in terms of network traffic because it requires an addition batch request to the PFAM servers to define the domains. The UniProt records only hold references to PFAM domains, but lack the necessary details to build informative domain data structures. However, like NCBI, UniProt servers do offer a batch request mode, which is utilized in `batch_get`  methods.\r\n\r\nIf `uniprotShortcut` is set to `True` then we default to the UniProt servers instead of NCBI for those accessions not beginning with O, P or Q. However, **geeneus** still provides UniProt fallback for those O/P/Q records, should they fail on NCBI lookup.\r\n\r\nThe user is totally oblivious to this behavior - **geeneus** provides an entirely uniform access to the information regardless of its source. To check which database a record has come from you can do\r\n\r\n       manager.get_record_source(ID)\r\n\r\nWhich returns the remote database type from which the record associated with accession ID was obtained. Note that if ID is not already in the datastore this will trigger the record to be fetched.\r\n\r\n### Caching \r\nLocal and temporary caching is an important feature of **geeneus** which helps make it an ideal tool for interactive data exploration. The manager object builds up a local data structure, and by default caches the records it fetches from remote database. The upshot of this from the user's perspective is that if I run\r\n\r\n    manager.get_protein_sequence(\"NP_001120968\")\r\n    manager.get_protein_sequence(\"NP_001120968\")\r\n\r\nThe second call doesn't query the database, but just reads off the cached value. This caching behavior can be turned off on by setting `cache=False` when initializing the ProteinManager object.\r\n\r\n\r\n### Batch queries \r\nA key design decision was how to deal with batch queries.\r\n\r\nThe eUtils recommended approach for making large (100+ IDs) queries is to initially ePost a list of those queries. The ePost operation sends this list to the ENTREZ servers, returning a `WebEnv` value and a `QueryKey` value. These two can then be used with an `eFetch` to go to the sever and get the result of the list submitted previously. The difficulty is that this list *must* be made up of UIDs (unique identifiers) which for proteins means GI numbers. If you only have an accession value (as is common) the only way to get this GI number is to query the database, and this `eSearch` operation can *not* be done in batch. Essentially, this is a chicken and egg problem - to get the GIs we need to do an `ePost` based batch query we have to run serial database queries.\r\n\r\nThis means that using `ePost`/`eFetch` would be great if you had a list of UIDs, but in practice accession numbers are a lot more common and useful, and the mapping of *n* accession values to UIDs would require *n* calls the server anyway. \r\n\r\nTo get around this, I use concatenated `eFetch` calls for batch queries, whereby a single call is submitted with a list of IDs. This is a fast and stable way to get around this problem, and, so far, as shown no issues with lists up to 100 IDs long. The potential issue is that the HTTP GET request being made here literally gets longer as we add accession values, so this represents a top limit in terms of networking protocols. However, I implemented a recursive cascading retry mechanism which halves the list and retries each half, so should a list be too long it should only result in two calls instead of one.\r\n\r\n### Robustness\r\nA primary goal with **geeneus** was to create an API which is robust to input. By this, it should be able to handle case insensitivity, convert accession values where necessary, and correctly recognize valid accession values while rejecting irrelevant ones to minimize server burden. For accession filtering, we use regular expressions to ensure the only accession values which we query could be real values (based on NCBI's [accession rules](http://www.ncbi.nlm.nih.gov/Sequin/acc.html). \r\n\r\nWhile PDBs don't fall into this category, we allow translation between PDBID and GI, although often a chain identifier is required as the NCBI protein database treats separate chains as separate records.\r\n\r\nAll the networking is dealt with in a highly modular fashion, and network failure tolerance is a priority.\r\n\r\n### Missing/badly formatted records\r\nIn all cases (as of 0.1.9) **geeneus** will skip over accession numbers which are\r\n\r\n1. Invalid\r\n2. Missing\r\n3. Link to poorly formatted XML data \r\n4. Link to XML data missing information\r\n\r\nThis means that, as of 0.1.9, you shouldn't have to use a `try:` and `Except:` block when running **geeneus** functions. Appropriate warning messages will be printed to standard output. \r\n\r\n## Background and license\r\nThis code was developed and is maintained by [Alex Holehouse](http://holehouse.org) at [Washington University in Saint Louis](http://www.wustl.edu/) as part of the [Naegle lab](http://naegle.wustl.edu/people/lab_members.html). It is licensed under the the GNU General Public License (GPL-2.0). For more information see LICENCE.\r\n\r\n### Acknowledgement\r\nA truly massive hat tip to Matt Matlock for countless suggestions, discussions and constant feedback regarding geeneus in a production setting. Matt has significantly shaped this code for the better, and it would be nothing like it is today without his input (the need for isoform support, domain support, the idea for shortcutting etc etc).\r\n","google":"UA-26309586-2","note":"Don't delete this file! It's used internally to help with page regeneration."}